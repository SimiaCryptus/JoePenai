/*
 * Mistral AI API
 * Chat Completion and Embeddings APIs
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.simiacryptus.api.java.mistral.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.simiacryptus.api.java.mistral.model.ChatCompletionRequestMessagesInner;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.StringJoiner;

/**
 * ChatCompletionRequest
 */
@JsonPropertyOrder({
  ChatCompletionRequest.JSON_PROPERTY_MODEL,
  ChatCompletionRequest.JSON_PROPERTY_MESSAGES,
  ChatCompletionRequest.JSON_PROPERTY_TEMPERATURE,
  ChatCompletionRequest.JSON_PROPERTY_TOP_P,
  ChatCompletionRequest.JSON_PROPERTY_MAX_TOKENS,
  ChatCompletionRequest.JSON_PROPERTY_STREAM,
  ChatCompletionRequest.JSON_PROPERTY_SAFE_PROMPT,
  ChatCompletionRequest.JSON_PROPERTY_RANDOM_SEED
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-09T16:24:59.450958200-05:00[America/New_York]")
public class ChatCompletionRequest {
  public static final String JSON_PROPERTY_MODEL = "model";
  private String model;

  public static final String JSON_PROPERTY_MESSAGES = "messages";
  private List<ChatCompletionRequestMessagesInner> messages = new ArrayList<>();

  public static final String JSON_PROPERTY_TEMPERATURE = "temperature";
  private JsonNullable<BigDecimal> temperature = JsonNullable.<BigDecimal>of(new BigDecimal("0.7"));

  public static final String JSON_PROPERTY_TOP_P = "top_p";
  private JsonNullable<BigDecimal> topP = JsonNullable.<BigDecimal>of(new BigDecimal("1"));

  public static final String JSON_PROPERTY_MAX_TOKENS = "max_tokens";
  private JsonNullable<Integer> maxTokens = JsonNullable.<Integer>undefined();

  public static final String JSON_PROPERTY_STREAM = "stream";
  private JsonNullable<Boolean> stream = JsonNullable.<Boolean>of(false);

  public static final String JSON_PROPERTY_SAFE_PROMPT = "safe_prompt";
  private Boolean safePrompt = false;

  public static final String JSON_PROPERTY_RANDOM_SEED = "random_seed";
  private Integer randomSeed;

  public ChatCompletionRequest() {
  }

  public ChatCompletionRequest model(String model) {
    
    this.model = model;
    return this;
  }

   /**
   * ID of the model to use. You can use the [List Available Models](/api#operation/listModels) API to see all of your available models, or see our [Model overview](/models) for model descriptions. 
   * @return model
  **/
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_MODEL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getModel() {
    return model;
  }


  @JsonProperty(JSON_PROPERTY_MODEL)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setModel(String model) {
    this.model = model;
  }


  public ChatCompletionRequest messages(List<ChatCompletionRequestMessagesInner> messages) {
    
    this.messages = messages;
    return this;
  }

  public ChatCompletionRequest addMessagesItem(ChatCompletionRequestMessagesInner messagesItem) {
    if (this.messages == null) {
      this.messages = new ArrayList<>();
    }
    this.messages.add(messagesItem);
    return this;
  }

   /**
   * The prompt(s) to generate completions for, encoded as a list of dict with role and content. The first prompt role should be &#x60;user&#x60; or &#x60;system&#x60;. 
   * @return messages
  **/
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_MESSAGES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<ChatCompletionRequestMessagesInner> getMessages() {
    return messages;
  }


  @JsonProperty(JSON_PROPERTY_MESSAGES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMessages(List<ChatCompletionRequestMessagesInner> messages) {
    this.messages = messages;
  }


  public ChatCompletionRequest temperature(BigDecimal temperature) {
    this.temperature = JsonNullable.<BigDecimal>of(temperature);
    
    return this;
  }

   /**
   * What sampling temperature to use, between 0.0 and 1.0. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or &#x60;top_p&#x60; but not both. 
   * minimum: 0
   * maximum: 1
   * @return temperature
  **/
  @javax.annotation.Nullable
  @JsonIgnore

  public BigDecimal getTemperature() {
        return temperature.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_TEMPERATURE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<BigDecimal> getTemperature_JsonNullable() {
    return temperature;
  }
  
  @JsonProperty(JSON_PROPERTY_TEMPERATURE)
  public void setTemperature_JsonNullable(JsonNullable<BigDecimal> temperature) {
    this.temperature = temperature;
  }

  public void setTemperature(BigDecimal temperature) {
    this.temperature = JsonNullable.<BigDecimal>of(temperature);
  }


  public ChatCompletionRequest topP(BigDecimal topP) {
    this.topP = JsonNullable.<BigDecimal>of(topP);
    
    return this;
  }

   /**
   * Nucleus sampling, where the model considers the results of the tokens with &#x60;top_p&#x60; probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or &#x60;temperature&#x60; but not both. 
   * minimum: 0
   * maximum: 1
   * @return topP
  **/
  @javax.annotation.Nullable
  @JsonIgnore

  public BigDecimal getTopP() {
        return topP.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_TOP_P)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<BigDecimal> getTopP_JsonNullable() {
    return topP;
  }
  
  @JsonProperty(JSON_PROPERTY_TOP_P)
  public void setTopP_JsonNullable(JsonNullable<BigDecimal> topP) {
    this.topP = topP;
  }

  public void setTopP(BigDecimal topP) {
    this.topP = JsonNullable.<BigDecimal>of(topP);
  }


  public ChatCompletionRequest maxTokens(Integer maxTokens) {
    this.maxTokens = JsonNullable.<Integer>of(maxTokens);
    
    return this;
  }

   /**
   * The maximum number of tokens to generate in the completion.  The token count of your prompt plus &#x60;max_tokens&#x60; cannot exceed the model&#39;s context length.  
   * minimum: 0
   * @return maxTokens
  **/
  @javax.annotation.Nullable
  @JsonIgnore

  public Integer getMaxTokens() {
        return maxTokens.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_MAX_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Integer> getMaxTokens_JsonNullable() {
    return maxTokens;
  }
  
  @JsonProperty(JSON_PROPERTY_MAX_TOKENS)
  public void setMaxTokens_JsonNullable(JsonNullable<Integer> maxTokens) {
    this.maxTokens = maxTokens;
  }

  public void setMaxTokens(Integer maxTokens) {
    this.maxTokens = JsonNullable.<Integer>of(maxTokens);
  }


  public ChatCompletionRequest stream(Boolean stream) {
    this.stream = JsonNullable.<Boolean>of(stream);
    
    return this;
  }

   /**
   * Whether to stream back partial progress. If set, tokens will be sent as data-only server-sent events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON. 
   * @return stream
  **/
  @javax.annotation.Nullable
  @JsonIgnore

  public Boolean getStream() {
        return stream.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_STREAM)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Boolean> getStream_JsonNullable() {
    return stream;
  }
  
  @JsonProperty(JSON_PROPERTY_STREAM)
  public void setStream_JsonNullable(JsonNullable<Boolean> stream) {
    this.stream = stream;
  }

  public void setStream(Boolean stream) {
    this.stream = JsonNullable.<Boolean>of(stream);
  }


  public ChatCompletionRequest safePrompt(Boolean safePrompt) {
    
    this.safePrompt = safePrompt;
    return this;
  }

   /**
   * Whether to inject a safety prompt before all conversations. 
   * @return safePrompt
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SAFE_PROMPT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getSafePrompt() {
    return safePrompt;
  }


  @JsonProperty(JSON_PROPERTY_SAFE_PROMPT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSafePrompt(Boolean safePrompt) {
    this.safePrompt = safePrompt;
  }


  public ChatCompletionRequest randomSeed(Integer randomSeed) {
    
    this.randomSeed = randomSeed;
    return this;
  }

   /**
   * The seed to use for random sampling. If set, different calls will generate deterministic results. 
   * @return randomSeed
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RANDOM_SEED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getRandomSeed() {
    return randomSeed;
  }


  @JsonProperty(JSON_PROPERTY_RANDOM_SEED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRandomSeed(Integer randomSeed) {
    this.randomSeed = randomSeed;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ChatCompletionRequest chatCompletionRequest = (ChatCompletionRequest) o;
    return Objects.equals(this.model, chatCompletionRequest.model) &&
        Objects.equals(this.messages, chatCompletionRequest.messages) &&
        equalsNullable(this.temperature, chatCompletionRequest.temperature) &&
        equalsNullable(this.topP, chatCompletionRequest.topP) &&
        equalsNullable(this.maxTokens, chatCompletionRequest.maxTokens) &&
        equalsNullable(this.stream, chatCompletionRequest.stream) &&
        Objects.equals(this.safePrompt, chatCompletionRequest.safePrompt) &&
        Objects.equals(this.randomSeed, chatCompletionRequest.randomSeed);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(model, messages, hashCodeNullable(temperature), hashCodeNullable(topP), hashCodeNullable(maxTokens), hashCodeNullable(stream), safePrompt, randomSeed);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ChatCompletionRequest {\n");
    sb.append("    model: ").append(toIndentedString(model)).append("\n");
    sb.append("    messages: ").append(toIndentedString(messages)).append("\n");
    sb.append("    temperature: ").append(toIndentedString(temperature)).append("\n");
    sb.append("    topP: ").append(toIndentedString(topP)).append("\n");
    sb.append("    maxTokens: ").append(toIndentedString(maxTokens)).append("\n");
    sb.append("    stream: ").append(toIndentedString(stream)).append("\n");
    sb.append("    safePrompt: ").append(toIndentedString(safePrompt)).append("\n");
    sb.append("    randomSeed: ").append(toIndentedString(randomSeed)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `model` to the URL query string
    if (getModel() != null) {
      try {
        joiner.add(String.format("%smodel%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getModel()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `messages` to the URL query string
    if (getMessages() != null) {
      for (int i = 0; i < getMessages().size(); i++) {
        if (getMessages().get(i) != null) {
          joiner.add(getMessages().get(i).toUrlQueryString(String.format("%smessages%s%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `temperature` to the URL query string
    if (getTemperature() != null) {
      try {
        joiner.add(String.format("%stemperature%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getTemperature()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `top_p` to the URL query string
    if (getTopP() != null) {
      try {
        joiner.add(String.format("%stop_p%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getTopP()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `max_tokens` to the URL query string
    if (getMaxTokens() != null) {
      try {
        joiner.add(String.format("%smax_tokens%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getMaxTokens()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `stream` to the URL query string
    if (getStream() != null) {
      try {
        joiner.add(String.format("%sstream%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getStream()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `safe_prompt` to the URL query string
    if (getSafePrompt() != null) {
      try {
        joiner.add(String.format("%ssafe_prompt%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getSafePrompt()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `random_seed` to the URL query string
    if (getRandomSeed() != null) {
      try {
        joiner.add(String.format("%srandom_seed%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getRandomSeed()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    return joiner.toString();
  }

}

