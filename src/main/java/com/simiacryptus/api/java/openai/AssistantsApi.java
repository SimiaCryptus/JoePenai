/*
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.simiacryptus.api.java.openai;

import com.fasterxml.jackson.core.type.TypeReference;

import com.simiacryptus.api.java.ApiException;
import com.simiacryptus.api.java.ApiClient;
import com.simiacryptus.api.java.Configuration;
import com.simiacryptus.api.java.Pair;

import com.simiacryptus.api.java.openai.model.AssistantFileObject;
import com.simiacryptus.api.java.openai.model.AssistantObject;
import com.simiacryptus.api.java.openai.model.CreateAssistantFileRequest;
import com.simiacryptus.api.java.openai.model.CreateAssistantRequest;
import com.simiacryptus.api.java.openai.model.CreateMessageRequest;
import com.simiacryptus.api.java.openai.model.CreateRunRequest;
import com.simiacryptus.api.java.openai.model.CreateThreadAndRunRequest;
import com.simiacryptus.api.java.openai.model.CreateThreadRequest;
import com.simiacryptus.api.java.openai.model.DeleteAssistantFileResponse;
import com.simiacryptus.api.java.openai.model.DeleteAssistantResponse;
import com.simiacryptus.api.java.openai.model.DeleteThreadResponse;
import com.simiacryptus.api.java.openai.model.ListAssistantFilesResponse;
import com.simiacryptus.api.java.openai.model.ListAssistantsResponse;
import com.simiacryptus.api.java.openai.model.ListMessageFilesResponse;
import com.simiacryptus.api.java.openai.model.ListMessagesResponse;
import com.simiacryptus.api.java.openai.model.ListRunStepsResponse;
import com.simiacryptus.api.java.openai.model.ListRunsResponse;
import com.simiacryptus.api.java.openai.model.MessageFileObject;
import com.simiacryptus.api.java.openai.model.MessageObject;
import com.simiacryptus.api.java.openai.model.ModifyAssistantRequest;
import com.simiacryptus.api.java.openai.model.ModifyMessageRequest;
import com.simiacryptus.api.java.openai.model.ModifyRunRequest;
import com.simiacryptus.api.java.openai.model.ModifyThreadRequest;
import com.simiacryptus.api.java.openai.model.RunObject;
import com.simiacryptus.api.java.openai.model.RunStepObject;
import com.simiacryptus.api.java.openai.model.SubmitToolOutputsRunRequest;
import com.simiacryptus.api.java.openai.model.ThreadObject;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-03-09T16:24:46.732753800-05:00[America/New_York]")
public class AssistantsApi {


  private ApiClient apiClient;

  public AssistantsApi() {
    this(Configuration.getDefaultApiClient());
  }

  public AssistantsApi(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return apiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Cancels a run that is &#x60;in_progress&#x60;.
   * 
   * @param threadId The ID of the thread to which this run belongs. (required)
   * @param runId The ID of the run to cancel. (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject cancelRun(String threadId, String runId) throws ApiException {
    return this.cancelRun(threadId, runId, Collections.emptyMap());
  }


  /**
   * Cancels a run that is &#x60;in_progress&#x60;.
   * 
   * @param threadId The ID of the thread to which this run belongs. (required)
   * @param runId The ID of the run to cancel. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject cancelRun(String threadId, String runId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling cancelRun");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling cancelRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}/cancel"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(runId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create an assistant with a model and instructions.
   * 
   * @param createAssistantRequest  (required)
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject createAssistant(CreateAssistantRequest createAssistantRequest) throws ApiException {
    return this.createAssistant(createAssistantRequest, Collections.emptyMap());
  }


  /**
   * Create an assistant with a model and instructions.
   * 
   * @param createAssistantRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject createAssistant(CreateAssistantRequest createAssistantRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createAssistantRequest;
    
    // verify the required parameter 'createAssistantRequest' is set
    if (createAssistantRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createAssistantRequest' when calling createAssistant");
    }
    
    // create path and map variables
    String localVarPath = "/assistants";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<AssistantObject> localVarReturnType = new TypeReference<AssistantObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
   * 
   * @param assistantId The ID of the assistant for which to create a File.  (required)
   * @param createAssistantFileRequest  (required)
   * @return AssistantFileObject
   * @throws ApiException if fails to make API call
   */
  public AssistantFileObject createAssistantFile(String assistantId, CreateAssistantFileRequest createAssistantFileRequest) throws ApiException {
    return this.createAssistantFile(assistantId, createAssistantFileRequest, Collections.emptyMap());
  }


  /**
   * Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
   * 
   * @param assistantId The ID of the assistant for which to create a File.  (required)
   * @param createAssistantFileRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return AssistantFileObject
   * @throws ApiException if fails to make API call
   */
  public AssistantFileObject createAssistantFile(String assistantId, CreateAssistantFileRequest createAssistantFileRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createAssistantFileRequest;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling createAssistantFile");
    }
    
    // verify the required parameter 'createAssistantFileRequest' is set
    if (createAssistantFileRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createAssistantFileRequest' when calling createAssistantFile");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}/files"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(assistantId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<AssistantFileObject> localVarReturnType = new TypeReference<AssistantFileObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a message.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for. (required)
   * @param createMessageRequest  (required)
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject createMessage(String threadId, CreateMessageRequest createMessageRequest) throws ApiException {
    return this.createMessage(threadId, createMessageRequest, Collections.emptyMap());
  }


  /**
   * Create a message.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for. (required)
   * @param createMessageRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject createMessage(String threadId, CreateMessageRequest createMessageRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createMessageRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling createMessage");
    }
    
    // verify the required parameter 'createMessageRequest' is set
    if (createMessageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createMessageRequest' when calling createMessage");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<MessageObject> localVarReturnType = new TypeReference<MessageObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a run.
   * 
   * @param threadId The ID of the thread to run. (required)
   * @param createRunRequest  (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject createRun(String threadId, CreateRunRequest createRunRequest) throws ApiException {
    return this.createRun(threadId, createRunRequest, Collections.emptyMap());
  }


  /**
   * Create a run.
   * 
   * @param threadId The ID of the thread to run. (required)
   * @param createRunRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject createRun(String threadId, CreateRunRequest createRunRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createRunRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling createRun");
    }
    
    // verify the required parameter 'createRunRequest' is set
    if (createRunRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createRunRequest' when calling createRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a thread.
   * 
   * @param createThreadRequest  (optional)
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject createThread(CreateThreadRequest createThreadRequest) throws ApiException {
    return this.createThread(createThreadRequest, Collections.emptyMap());
  }


  /**
   * Create a thread.
   * 
   * @param createThreadRequest  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject createThread(CreateThreadRequest createThreadRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createThreadRequest;
    
    // create path and map variables
    String localVarPath = "/threads";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ThreadObject> localVarReturnType = new TypeReference<ThreadObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a thread and run it in one request.
   * 
   * @param createThreadAndRunRequest  (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject createThreadAndRun(CreateThreadAndRunRequest createThreadAndRunRequest) throws ApiException {
    return this.createThreadAndRun(createThreadAndRunRequest, Collections.emptyMap());
  }


  /**
   * Create a thread and run it in one request.
   * 
   * @param createThreadAndRunRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject createThreadAndRun(CreateThreadAndRunRequest createThreadAndRunRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createThreadAndRunRequest;
    
    // verify the required parameter 'createThreadAndRunRequest' is set
    if (createThreadAndRunRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createThreadAndRunRequest' when calling createThreadAndRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/runs";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an assistant.
   * 
   * @param assistantId The ID of the assistant to delete. (required)
   * @return DeleteAssistantResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteAssistantResponse deleteAssistant(String assistantId) throws ApiException {
    return this.deleteAssistant(assistantId, Collections.emptyMap());
  }


  /**
   * Delete an assistant.
   * 
   * @param assistantId The ID of the assistant to delete. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return DeleteAssistantResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteAssistantResponse deleteAssistant(String assistantId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling deleteAssistant");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(assistantId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<DeleteAssistantResponse> localVarReturnType = new TypeReference<DeleteAssistantResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an assistant file.
   * 
   * @param assistantId The ID of the assistant that the file belongs to. (required)
   * @param fileId The ID of the file to delete. (required)
   * @return DeleteAssistantFileResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteAssistantFileResponse deleteAssistantFile(String assistantId, String fileId) throws ApiException {
    return this.deleteAssistantFile(assistantId, fileId, Collections.emptyMap());
  }


  /**
   * Delete an assistant file.
   * 
   * @param assistantId The ID of the assistant that the file belongs to. (required)
   * @param fileId The ID of the file to delete. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return DeleteAssistantFileResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteAssistantFileResponse deleteAssistantFile(String assistantId, String fileId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling deleteAssistantFile");
    }
    
    // verify the required parameter 'fileId' is set
    if (fileId == null) {
      throw new ApiException(400, "Missing the required parameter 'fileId' when calling deleteAssistantFile");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}/files/{file_id}"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(assistantId.toString()))
      .replaceAll("\\{" + "file_id" + "\\}", apiClient.escapeString(fileId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<DeleteAssistantFileResponse> localVarReturnType = new TypeReference<DeleteAssistantFileResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete a thread.
   * 
   * @param threadId The ID of the thread to delete. (required)
   * @return DeleteThreadResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteThreadResponse deleteThread(String threadId) throws ApiException {
    return this.deleteThread(threadId, Collections.emptyMap());
  }


  /**
   * Delete a thread.
   * 
   * @param threadId The ID of the thread to delete. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return DeleteThreadResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteThreadResponse deleteThread(String threadId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling deleteThread");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<DeleteThreadResponse> localVarReturnType = new TypeReference<DeleteThreadResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves an assistant.
   * 
   * @param assistantId The ID of the assistant to retrieve. (required)
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject getAssistant(String assistantId) throws ApiException {
    return this.getAssistant(assistantId, Collections.emptyMap());
  }


  /**
   * Retrieves an assistant.
   * 
   * @param assistantId The ID of the assistant to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject getAssistant(String assistantId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling getAssistant");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(assistantId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<AssistantObject> localVarReturnType = new TypeReference<AssistantObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves an AssistantFile.
   * 
   * @param assistantId The ID of the assistant who the file belongs to. (required)
   * @param fileId The ID of the file we&#39;re getting. (required)
   * @return AssistantFileObject
   * @throws ApiException if fails to make API call
   */
  public AssistantFileObject getAssistantFile(String assistantId, String fileId) throws ApiException {
    return this.getAssistantFile(assistantId, fileId, Collections.emptyMap());
  }


  /**
   * Retrieves an AssistantFile.
   * 
   * @param assistantId The ID of the assistant who the file belongs to. (required)
   * @param fileId The ID of the file we&#39;re getting. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return AssistantFileObject
   * @throws ApiException if fails to make API call
   */
  public AssistantFileObject getAssistantFile(String assistantId, String fileId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling getAssistantFile");
    }
    
    // verify the required parameter 'fileId' is set
    if (fileId == null) {
      throw new ApiException(400, "Missing the required parameter 'fileId' when calling getAssistantFile");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}/files/{file_id}"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(assistantId.toString()))
      .replaceAll("\\{" + "file_id" + "\\}", apiClient.escapeString(fileId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<AssistantFileObject> localVarReturnType = new TypeReference<AssistantFileObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieve a message.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs. (required)
   * @param messageId The ID of the message to retrieve. (required)
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject getMessage(String threadId, String messageId) throws ApiException {
    return this.getMessage(threadId, messageId, Collections.emptyMap());
  }


  /**
   * Retrieve a message.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs. (required)
   * @param messageId The ID of the message to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject getMessage(String threadId, String messageId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getMessage");
    }
    
    // verify the required parameter 'messageId' is set
    if (messageId == null) {
      throw new ApiException(400, "Missing the required parameter 'messageId' when calling getMessage");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages/{message_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "message_id" + "\\}", apiClient.escapeString(messageId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<MessageObject> localVarReturnType = new TypeReference<MessageObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves a message file.
   * 
   * @param threadId The ID of the thread to which the message and File belong. (required)
   * @param messageId The ID of the message the file belongs to. (required)
   * @param fileId The ID of the file being retrieved. (required)
   * @return MessageFileObject
   * @throws ApiException if fails to make API call
   */
  public MessageFileObject getMessageFile(String threadId, String messageId, String fileId) throws ApiException {
    return this.getMessageFile(threadId, messageId, fileId, Collections.emptyMap());
  }


  /**
   * Retrieves a message file.
   * 
   * @param threadId The ID of the thread to which the message and File belong. (required)
   * @param messageId The ID of the message the file belongs to. (required)
   * @param fileId The ID of the file being retrieved. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return MessageFileObject
   * @throws ApiException if fails to make API call
   */
  public MessageFileObject getMessageFile(String threadId, String messageId, String fileId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getMessageFile");
    }
    
    // verify the required parameter 'messageId' is set
    if (messageId == null) {
      throw new ApiException(400, "Missing the required parameter 'messageId' when calling getMessageFile");
    }
    
    // verify the required parameter 'fileId' is set
    if (fileId == null) {
      throw new ApiException(400, "Missing the required parameter 'fileId' when calling getMessageFile");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages/{message_id}/files/{file_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "message_id" + "\\}", apiClient.escapeString(messageId.toString()))
      .replaceAll("\\{" + "file_id" + "\\}", apiClient.escapeString(fileId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<MessageFileObject> localVarReturnType = new TypeReference<MessageFileObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves a run.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run. (required)
   * @param runId The ID of the run to retrieve. (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject getRun(String threadId, String runId) throws ApiException {
    return this.getRun(threadId, runId, Collections.emptyMap());
  }


  /**
   * Retrieves a run.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run. (required)
   * @param runId The ID of the run to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject getRun(String threadId, String runId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getRun");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling getRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(runId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves a run step.
   * 
   * @param threadId The ID of the thread to which the run and run step belongs. (required)
   * @param runId The ID of the run to which the run step belongs. (required)
   * @param stepId The ID of the run step to retrieve. (required)
   * @return RunStepObject
   * @throws ApiException if fails to make API call
   */
  public RunStepObject getRunStep(String threadId, String runId, String stepId) throws ApiException {
    return this.getRunStep(threadId, runId, stepId, Collections.emptyMap());
  }


  /**
   * Retrieves a run step.
   * 
   * @param threadId The ID of the thread to which the run and run step belongs. (required)
   * @param runId The ID of the run to which the run step belongs. (required)
   * @param stepId The ID of the run step to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunStepObject
   * @throws ApiException if fails to make API call
   */
  public RunStepObject getRunStep(String threadId, String runId, String stepId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getRunStep");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling getRunStep");
    }
    
    // verify the required parameter 'stepId' is set
    if (stepId == null) {
      throw new ApiException(400, "Missing the required parameter 'stepId' when calling getRunStep");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}/steps/{step_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(runId.toString()))
      .replaceAll("\\{" + "step_id" + "\\}", apiClient.escapeString(stepId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunStepObject> localVarReturnType = new TypeReference<RunStepObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves a thread.
   * 
   * @param threadId The ID of the thread to retrieve. (required)
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject getThread(String threadId) throws ApiException {
    return this.getThread(threadId, Collections.emptyMap());
  }


  /**
   * Retrieves a thread.
   * 
   * @param threadId The ID of the thread to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject getThread(String threadId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getThread");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ThreadObject> localVarReturnType = new TypeReference<ThreadObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of assistant files.
   * 
   * @param assistantId The ID of the assistant the file belongs to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @return ListAssistantFilesResponse
   * @throws ApiException if fails to make API call
   */
  public ListAssistantFilesResponse listAssistantFiles(String assistantId, Integer limit, String order, String after, String before) throws ApiException {
    return this.listAssistantFiles(assistantId, limit, order, after, before, Collections.emptyMap());
  }


  /**
   * Returns a list of assistant files.
   * 
   * @param assistantId The ID of the assistant the file belongs to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListAssistantFilesResponse
   * @throws ApiException if fails to make API call
   */
  public ListAssistantFilesResponse listAssistantFiles(String assistantId, Integer limit, String order, String after, String before, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling listAssistantFiles");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}/files"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(assistantId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListAssistantFilesResponse> localVarReturnType = new TypeReference<ListAssistantFilesResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of assistants.
   * 
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @return ListAssistantsResponse
   * @throws ApiException if fails to make API call
   */
  public ListAssistantsResponse listAssistants(Integer limit, String order, String after, String before) throws ApiException {
    return this.listAssistants(limit, order, after, before, Collections.emptyMap());
  }


  /**
   * Returns a list of assistants.
   * 
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListAssistantsResponse
   * @throws ApiException if fails to make API call
   */
  public ListAssistantsResponse listAssistants(Integer limit, String order, String after, String before, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/assistants";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListAssistantsResponse> localVarReturnType = new TypeReference<ListAssistantsResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of message files.
   * 
   * @param threadId The ID of the thread that the message and files belong to. (required)
   * @param messageId The ID of the message that the files belongs to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @return ListMessageFilesResponse
   * @throws ApiException if fails to make API call
   */
  public ListMessageFilesResponse listMessageFiles(String threadId, String messageId, Integer limit, String order, String after, String before) throws ApiException {
    return this.listMessageFiles(threadId, messageId, limit, order, after, before, Collections.emptyMap());
  }


  /**
   * Returns a list of message files.
   * 
   * @param threadId The ID of the thread that the message and files belong to. (required)
   * @param messageId The ID of the message that the files belongs to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListMessageFilesResponse
   * @throws ApiException if fails to make API call
   */
  public ListMessageFilesResponse listMessageFiles(String threadId, String messageId, Integer limit, String order, String after, String before, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling listMessageFiles");
    }
    
    // verify the required parameter 'messageId' is set
    if (messageId == null) {
      throw new ApiException(400, "Missing the required parameter 'messageId' when calling listMessageFiles");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages/{message_id}/files"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "message_id" + "\\}", apiClient.escapeString(messageId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListMessageFilesResponse> localVarReturnType = new TypeReference<ListMessageFilesResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of messages for a given thread.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @return ListMessagesResponse
   * @throws ApiException if fails to make API call
   */
  public ListMessagesResponse listMessages(String threadId, Integer limit, String order, String after, String before) throws ApiException {
    return this.listMessages(threadId, limit, order, after, before, Collections.emptyMap());
  }


  /**
   * Returns a list of messages for a given thread.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListMessagesResponse
   * @throws ApiException if fails to make API call
   */
  public ListMessagesResponse listMessages(String threadId, Integer limit, String order, String after, String before, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling listMessages");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListMessagesResponse> localVarReturnType = new TypeReference<ListMessagesResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of run steps belonging to a run.
   * 
   * @param threadId The ID of the thread the run and run steps belong to. (required)
   * @param runId The ID of the run the run steps belong to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @return ListRunStepsResponse
   * @throws ApiException if fails to make API call
   */
  public ListRunStepsResponse listRunSteps(String threadId, String runId, Integer limit, String order, String after, String before) throws ApiException {
    return this.listRunSteps(threadId, runId, limit, order, after, before, Collections.emptyMap());
  }


  /**
   * Returns a list of run steps belonging to a run.
   * 
   * @param threadId The ID of the thread the run and run steps belong to. (required)
   * @param runId The ID of the run the run steps belong to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListRunStepsResponse
   * @throws ApiException if fails to make API call
   */
  public ListRunStepsResponse listRunSteps(String threadId, String runId, Integer limit, String order, String after, String before, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling listRunSteps");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling listRunSteps");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}/steps"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(runId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListRunStepsResponse> localVarReturnType = new TypeReference<ListRunStepsResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of runs belonging to a thread.
   * 
   * @param threadId The ID of the thread the run belongs to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @return ListRunsResponse
   * @throws ApiException if fails to make API call
   */
  public ListRunsResponse listRuns(String threadId, Integer limit, String order, String after, String before) throws ApiException {
    return this.listRuns(threadId, limit, order, after, before, Collections.emptyMap());
  }


  /**
   * Returns a list of runs belonging to a thread.
   * 
   * @param threadId The ID of the thread the run belongs to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListRunsResponse
   * @throws ApiException if fails to make API call
   */
  public ListRunsResponse listRuns(String threadId, Integer limit, String order, String after, String before, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling listRuns");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListRunsResponse> localVarReturnType = new TypeReference<ListRunsResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Modifies an assistant.
   * 
   * @param assistantId The ID of the assistant to modify. (required)
   * @param modifyAssistantRequest  (required)
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject modifyAssistant(String assistantId, ModifyAssistantRequest modifyAssistantRequest) throws ApiException {
    return this.modifyAssistant(assistantId, modifyAssistantRequest, Collections.emptyMap());
  }


  /**
   * Modifies an assistant.
   * 
   * @param assistantId The ID of the assistant to modify. (required)
   * @param modifyAssistantRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject modifyAssistant(String assistantId, ModifyAssistantRequest modifyAssistantRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = modifyAssistantRequest;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling modifyAssistant");
    }
    
    // verify the required parameter 'modifyAssistantRequest' is set
    if (modifyAssistantRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'modifyAssistantRequest' when calling modifyAssistant");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(assistantId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<AssistantObject> localVarReturnType = new TypeReference<AssistantObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Modifies a message.
   * 
   * @param threadId The ID of the thread to which this message belongs. (required)
   * @param messageId The ID of the message to modify. (required)
   * @param modifyMessageRequest  (required)
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject modifyMessage(String threadId, String messageId, ModifyMessageRequest modifyMessageRequest) throws ApiException {
    return this.modifyMessage(threadId, messageId, modifyMessageRequest, Collections.emptyMap());
  }


  /**
   * Modifies a message.
   * 
   * @param threadId The ID of the thread to which this message belongs. (required)
   * @param messageId The ID of the message to modify. (required)
   * @param modifyMessageRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject modifyMessage(String threadId, String messageId, ModifyMessageRequest modifyMessageRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = modifyMessageRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling modifyMessage");
    }
    
    // verify the required parameter 'messageId' is set
    if (messageId == null) {
      throw new ApiException(400, "Missing the required parameter 'messageId' when calling modifyMessage");
    }
    
    // verify the required parameter 'modifyMessageRequest' is set
    if (modifyMessageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'modifyMessageRequest' when calling modifyMessage");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages/{message_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "message_id" + "\\}", apiClient.escapeString(messageId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<MessageObject> localVarReturnType = new TypeReference<MessageObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Modifies a run.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run. (required)
   * @param runId The ID of the run to modify. (required)
   * @param modifyRunRequest  (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject modifyRun(String threadId, String runId, ModifyRunRequest modifyRunRequest) throws ApiException {
    return this.modifyRun(threadId, runId, modifyRunRequest, Collections.emptyMap());
  }


  /**
   * Modifies a run.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run. (required)
   * @param runId The ID of the run to modify. (required)
   * @param modifyRunRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject modifyRun(String threadId, String runId, ModifyRunRequest modifyRunRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = modifyRunRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling modifyRun");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling modifyRun");
    }
    
    // verify the required parameter 'modifyRunRequest' is set
    if (modifyRunRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'modifyRunRequest' when calling modifyRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(runId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Modifies a thread.
   * 
   * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified. (required)
   * @param modifyThreadRequest  (required)
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject modifyThread(String threadId, ModifyThreadRequest modifyThreadRequest) throws ApiException {
    return this.modifyThread(threadId, modifyThreadRequest, Collections.emptyMap());
  }


  /**
   * Modifies a thread.
   * 
   * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified. (required)
   * @param modifyThreadRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject modifyThread(String threadId, ModifyThreadRequest modifyThreadRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = modifyThreadRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling modifyThread");
    }
    
    // verify the required parameter 'modifyThreadRequest' is set
    if (modifyThreadRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'modifyThreadRequest' when calling modifyThread");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ThreadObject> localVarReturnType = new TypeReference<ThreadObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs. (required)
   * @param runId The ID of the run that requires the tool output submission. (required)
   * @param submitToolOutputsRunRequest  (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject submitToolOuputsToRun(String threadId, String runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest) throws ApiException {
    return this.submitToolOuputsToRun(threadId, runId, submitToolOutputsRunRequest, Collections.emptyMap());
  }


  /**
   * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs. (required)
   * @param runId The ID of the run that requires the tool output submission. (required)
   * @param submitToolOutputsRunRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject submitToolOuputsToRun(String threadId, String runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = submitToolOutputsRunRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling submitToolOuputsToRun");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling submitToolOuputsToRun");
    }
    
    // verify the required parameter 'submitToolOutputsRunRequest' is set
    if (submitToolOutputsRunRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'submitToolOutputsRunRequest' when calling submitToolOuputsToRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(threadId.toString()))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(runId.toString()));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

}
